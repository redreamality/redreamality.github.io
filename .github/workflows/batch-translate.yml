name: Batch Translate Content

on:
  workflow_dispatch:
    inputs:
      target_language:
        description: 'Target language for translation'
        required: true
        type: choice
        options:
          - 'en'
          - 'zh'
        default: 'en'
      priority_filter:
        description: 'Priority filter for content to translate'
        required: true
        type: choice
        options:
          - 'all'
          - 'high'
          - 'medium'
          - 'low'
        default: 'high'
      content_type:
        description: 'Type of content to translate'
        required: true
        type: choice
        options:
          - 'all'
          - 'blog'
          - 'talks'
        default: 'all'
      max_items:
        description: 'Maximum number of items to translate (1-10)'
        required: false
        type: number
        default: 5
      auto_commit:
        description: 'Automatically commit translated files'
        required: false
        type: boolean
        default: false

  repository_dispatch:
    types: [batch-translate]

jobs:
  batch-translate:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm install

      - name: Create batch translation script
        run: |
          cat > batch-translate-script.js << 'EOF'
          const fs = require('fs');
          const path = require('path');

          // Translation configuration
          const TRANSLATION_CONFIG = {
            apiBase: process.env.OPENAI_API_BASE || 'https://gateway.chat.sensedeal.vip/v1',
            apiKey: process.env.OPENAI_API_KEY,
            model: process.env.MODEL || 'qwen2.5-32b-instruct-int4'
          };

          // Content analysis functions
          function analyzeContent(filePath, content) {
            const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---\n([\s\S]*)$/);
            if (!frontmatterMatch) return null;

            const frontmatter = frontmatterMatch[1];
            const bodyContent = frontmatterMatch[2];

            // Extract metadata
            const titleMatch = frontmatter.match(/title:\s*['"](.*)['"]/) || frontmatter.match(/title:\s*(.*)/);
            const title = titleMatch ? titleMatch[1].trim() : path.basename(filePath, '.md');

            const tagsMatch = frontmatter.match(/tags:\s*\[(.*)\]/);
            const tags = tagsMatch ? tagsMatch[1].split(',').map(tag => tag.trim().replace(/['"]/g, '')) : [];

            // Determine priority
            const priority = calculatePriority(title, tags, bodyContent);

            return {
              filePath,
              title,
              tags,
              priority,
              content,
              frontmatter,
              bodyContent
            };
          }

          function calculatePriority(title, tags, content) {
            const titleLower = title.toLowerCase();
            const tagsLower = tags.map(tag => tag.toLowerCase());
            const contentLower = content.toLowerCase();

            const highPriorityKeywords = [
              'multi-agent', 'ai', 'machine learning', 'tutorial', 'guide',
              'python', 'javascript', 'development', 'programming', 'technical'
            ];

            const mediumPriorityKeywords = [
              'blockchain', 'trading', 'finance', 'web', 'frontend', 'backend'
            ];

            const hasHighPriority = highPriorityKeywords.some(keyword => 
              titleLower.includes(keyword) || 
              tagsLower.some(tag => tag.includes(keyword)) ||
              contentLower.includes(keyword)
            );

            const hasMediumPriority = mediumPriorityKeywords.some(keyword => 
              titleLower.includes(keyword) || 
              tagsLower.some(tag => tag.includes(keyword)) ||
              contentLower.includes(keyword)
            );

            if (hasHighPriority) return 'high';
            if (hasMediumPriority) return 'medium';
            return 'low';
          }

          // Translation functions (same as single translation)
          async function translateContent(content, fromLang, toLang, contentType) {
            const fromLangName = fromLang === 'zh' ? 'Chinese' : 'English';
            const toLangName = toLang === 'zh' ? 'Chinese' : 'English';

            const systemPrompt = `You are a professional translator specializing in technical content translation from ${fromLangName} to ${toLangName}.

          Your task is to translate ${contentType} content while:
          - Maintaining technical accuracy and terminology
          - Preserving code examples and technical concepts
          - Ensuring natural flow in the target language
          - Keeping all Markdown formatting intact
          - Translating comments in code blocks when appropriate
          - Maintaining the same tone and style`;

            const userPrompt = `Translate the following ${contentType} content from ${fromLangName} to ${toLangName}:

          IMPORTANT: Preserve all Markdown formatting, code blocks, links, and structure exactly as they appear.

          ${content}`;

            try {
              const response = await fetch(`${TRANSLATION_CONFIG.apiBase}/chat/completions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${TRANSLATION_CONFIG.apiKey}`,
                },
                body: JSON.stringify({
                  model: TRANSLATION_CONFIG.model,
                  messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userPrompt }
                  ],
                  temperature: 0.3,
                  max_tokens: 4000,
                }),
              });

              if (!response.ok) {
                throw new Error(`Translation API error: ${response.status} ${response.statusText}`);
              }

              const data = await response.json();
              return data.choices?.[0]?.message?.content?.trim();
            } catch (error) {
              console.error('Translation error:', error);
              throw error;
            }
          }

          async function translateMetadata(metadata, fromLang, toLang) {
            const fromLangName = fromLang === 'zh' ? 'Chinese' : 'English';
            const toLangName = toLang === 'zh' ? 'Chinese' : 'English';

            const metadataText = JSON.stringify({
              title: metadata.title || '',
              description: metadata.description || '',
              tags: metadata.tags || [],
            });

            const prompt = `Translate the following JSON metadata from ${fromLangName} to ${toLangName}. Maintain the JSON structure and translate only the values:

          ${metadataText}

          Return only the translated JSON without any additional text or formatting.`;

            try {
              const response = await fetch(`${TRANSLATION_CONFIG.apiBase}/chat/completions`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${TRANSLATION_CONFIG.apiKey}`,
                },
                body: JSON.stringify({
                  model: TRANSLATION_CONFIG.model,
                  messages: [
                    {
                      role: 'system',
                      content: 'You are a professional translator. Translate the provided JSON metadata accurately while preserving the structure.'
                    },
                    { role: 'user', content: prompt }
                  ],
                  temperature: 0.2,
                  max_tokens: 1000,
                }),
              });

              if (!response.ok) {
                throw new Error(`Metadata translation API error: ${response.status}`);
              }

              const data = await response.json();
              const translatedText = data.choices?.[0]?.message?.content?.trim();
              return JSON.parse(translatedText);
            } catch (error) {
              console.error('Metadata translation error:', error);
              return metadata;
            }
          }

          // Main batch translation function
          async function batchTranslate(targetLang, priorityFilter, contentTypeFilter, maxItems) {
            console.log(`Starting batch translation to ${targetLang}...`);
            console.log(`Filters: priority=${priorityFilter}, type=${contentTypeFilter}, max=${maxItems}`);

            const sourceLang = targetLang === 'en' ? 'zh' : 'en';
            const sourceDirectories = [];
            
            // Determine source directories
            if (contentTypeFilter === 'all' || contentTypeFilter === 'blog') {
              sourceDirectories.push(sourceLang === 'zh' ? 'src/content/blog-cn' : 'src/content/blog-en');
            }
            if (contentTypeFilter === 'all' || contentTypeFilter === 'talks') {
              sourceDirectories.push(sourceLang === 'zh' ? 'src/content/talks-cn' : 'src/content/talks-en');
            }

            const candidates = [];

            // Scan for translation candidates
            for (const dir of sourceDirectories) {
              if (!fs.existsSync(dir)) {
                console.log(`Directory ${dir} does not exist, skipping...`);
                continue;
              }

              const files = fs.readdirSync(dir).filter(file => file.endsWith('.md'));
              
              for (const file of files) {
                const filePath = path.join(dir, file);
                const content = fs.readFileSync(filePath, 'utf8');
                const analysis = analyzeContent(filePath, content);
                
                if (analysis) {
                  // Check if translation already exists
                  const targetDir = dir.replace(
                    sourceLang === 'zh' ? /\/(blog|talks)$/ : /\/(blog|talks)-en$/,
                    targetLang === 'en' ? '/$1-en' : '/$1'
                  );
                  const targetPath = path.join(targetDir, file);
                  
                  if (!fs.existsSync(targetPath)) {
                    candidates.push({
                      ...analysis,
                      targetPath,
                      contentType: dir.includes('blog') ? 'blog' : 'talks'
                    });
                  }
                }
              }
            }

            // Filter by priority
            let filteredCandidates = candidates;
            if (priorityFilter !== 'all') {
              filteredCandidates = candidates.filter(c => c.priority === priorityFilter);
            }

            // Sort by priority (high -> medium -> low) and limit
            const priorityOrder = { high: 0, medium: 1, low: 2 };
            filteredCandidates.sort((a, b) => priorityOrder[a.priority] - priorityOrder[b.priority]);
            filteredCandidates = filteredCandidates.slice(0, maxItems);

            console.log(`Found ${filteredCandidates.length} items to translate:`);
            filteredCandidates.forEach(c => console.log(`- ${c.title} (${c.priority})`));

            const results = [];

            // Translate each item
            for (let i = 0; i < filteredCandidates.length; i++) {
              const item = filteredCandidates[i];
              console.log(`\nTranslating ${i + 1}/${filteredCandidates.length}: ${item.title}`);

              try {
                // Extract metadata for translation
                const descMatch = item.frontmatter.match(/description:\s*['"](.*)['"]/) || 
                                 item.frontmatter.match(/description:\s*(.*)/);
                const metadata = {
                  title: item.title,
                  description: descMatch ? descMatch[1].trim() : '',
                  tags: item.tags
                };

                // Translate content and metadata
                const translatedContent = await translateContent(
                  item.bodyContent, 
                  sourceLang, 
                  targetLang, 
                  item.contentType
                );
                
                const translatedMetadata = await translateMetadata(metadata, sourceLang, targetLang);

                // Reconstruct frontmatter
                let newFrontmatter = item.frontmatter;
                if (translatedMetadata.title) {
                  newFrontmatter = newFrontmatter.replace(
                    /title:\s*['"].*['"]/, 
                    `title: '${translatedMetadata.title.replace(/'/g, "''")}'`
                  );
                }
                if (translatedMetadata.description) {
                  newFrontmatter = newFrontmatter.replace(
                    /description:\s*['"].*['"]/, 
                    `description: '${translatedMetadata.description.replace(/'/g, "''")}'`
                  );
                }
                if (translatedMetadata.tags && translatedMetadata.tags.length > 0) {
                  const tagsString = translatedMetadata.tags.map(tag => `'${tag.replace(/'/g, "''")}'`).join(', ');
                  newFrontmatter = newFrontmatter.replace(/tags:\s*\[.*\]/, `tags: [${tagsString}]`);
                }

                // Write translated file
                const targetDir = path.dirname(item.targetPath);
                if (!fs.existsSync(targetDir)) {
                  fs.mkdirSync(targetDir, { recursive: true });
                }

                const translatedFile = `---\n${newFrontmatter}\n---\n\n${translatedContent}`;
                fs.writeFileSync(item.targetPath, translatedFile, 'utf8');

                results.push({
                  source: item.filePath,
                  target: item.targetPath,
                  title: item.title,
                  translatedTitle: translatedMetadata.title,
                  success: true
                });

                console.log(`‚úÖ Completed: ${item.targetPath}`);

                // Add delay between translations to avoid rate limiting
                if (i < filteredCandidates.length - 1) {
                  console.log('Waiting 3 seconds before next translation...');
                  await new Promise(resolve => setTimeout(resolve, 3000));
                }

              } catch (error) {
                console.error(`‚ùå Failed to translate ${item.title}:`, error);
                results.push({
                  source: item.filePath,
                  target: item.targetPath,
                  title: item.title,
                  success: false,
                  error: error.message
                });
              }
            }

            // Summary
            const successful = results.filter(r => r.success);
            const failed = results.filter(r => !r.success);

            console.log(`\nüìä Batch Translation Summary:`);
            console.log(`‚úÖ Successful: ${successful.length}`);
            console.log(`‚ùå Failed: ${failed.length}`);
            console.log(`üìÅ Total files created: ${successful.length}`);

            if (successful.length > 0) {
              console.log('\n‚úÖ Successfully translated:');
              successful.forEach(r => console.log(`- ${r.translatedTitle || r.title}`));
            }

            if (failed.length > 0) {
              console.log('\n‚ùå Failed translations:');
              failed.forEach(r => console.log(`- ${r.title}: ${r.error}`));
            }

            return results;
          }

          // Run batch translation
          const targetLang = process.argv[2];
          const priorityFilter = process.argv[3];
          const contentTypeFilter = process.argv[4];
          const maxItems = parseInt(process.argv[5]) || 5;

          batchTranslate(targetLang, priorityFilter, contentTypeFilter, maxItems)
            .then((results) => {
              const successful = results.filter(r => r.success);
              console.log(`\nüéâ Batch translation completed! ${successful.length} files translated.`);
              
              // Set output for GitHub Actions
              console.log(`::set-output name=translated_count::${successful.length}`);
              console.log(`::set-output name=failed_count::${results.length - successful.length}`);
            })
            .catch((error) => {
              console.error('‚ùå Batch translation failed:', error);
              process.exit(1);
            });
          EOF

      - name: Run batch translation
        id: batch_translate
        env:
          OPENAI_API_BASE: ${{ secrets.OPENAI_API_BASE || 'https://gateway.chat.sensedeal.vip/v1' }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY || 'b9df99ea41435fa7be5ce346b486c33e' }}
          MODEL: ${{ secrets.MODEL || 'qwen2.5-32b-instruct-int4' }}
        run: |
          node batch-translate-script.js "${{ github.event.inputs.target_language || github.event.client_payload.target_language }}" "${{ github.event.inputs.priority_filter || github.event.client_payload.priority_filter }}" "${{ github.event.inputs.content_type || github.event.client_payload.content_type }}" "${{ github.event.inputs.max_items || github.event.client_payload.max_items }}"

      - name: Commit translated files
        if: ${{ github.event.inputs.auto_commit == 'true' || github.event.client_payload.auto_commit == 'true' }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add .
          git commit -m "Batch translate content to ${{ github.event.inputs.target_language }}: ${{ steps.batch_translate.outputs.translated_count }} files" || echo "No changes to commit"
          git push

      - name: Create Pull Request
        if: ${{ github.event.inputs.auto_commit != 'true' && github.event.client_payload.auto_commit != 'true' }}
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "Batch translate content to ${{ github.event.inputs.target_language }}"
          title: "üåê Batch Translation: ${{ steps.batch_translate.outputs.translated_count }} files to ${{ github.event.inputs.target_language }}"
          body: |
            ## Batch Translation Results

            This PR contains automatically translated content:

            - **Target Language**: `${{ github.event.inputs.target_language }}`
            - **Priority Filter**: `${{ github.event.inputs.priority_filter }}`
            - **Content Type**: `${{ github.event.inputs.content_type }}`
            - **Max Items**: `${{ github.event.inputs.max_items }}`
            - **Model Used**: `${{ secrets.MODEL || 'qwen2.5-32b-instruct-int4' }}`

            ### Results
            - ‚úÖ **Successfully Translated**: ${{ steps.batch_translate.outputs.translated_count }} files
            - ‚ùå **Failed**: ${{ steps.batch_translate.outputs.failed_count }} files

            Please review the translation quality before merging.

            ### Review Checklist
            - [ ] Translation accuracy across all files
            - [ ] Technical terminology correctness
            - [ ] Markdown formatting preserved
            - [ ] Code blocks and links working
            - [ ] Metadata properly translated
            - [ ] Consistent terminology across translations

          branch: batch-translation/${{ github.event.inputs.target_language }}-${{ github.run_number }}
          delete-branch: true
