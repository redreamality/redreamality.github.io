---
title: '2025 年浏览器扩展框架现状：Plasmo、WXT 与 CRXJS 的对比分析'
pubDate: 2025-09-03T08:44:51.236Z
description: '2025 年的浏览器扩展开发领域因强制迁移至 Manifest V3（MV3）以及持续的跨浏览器 API 不一致而日益复杂。在这一充满挑战的环境中，已出现一位明确的市场领导者。通过对现有框架的功能集、开发者体验及生态系统健康状况的分析表明，**WXT** 已确立其作为现代浏览器扩展开发首选框架的领先地位。这一领导地位源于其卓越的开发者体验、强大而灵活的功能集、框架无关的架构所带来的广泛兼容性，以及最关键的——活跃且可靠的开源维护记录。'
author: 'Remy'
tags: ['浏览器扩展', '前端开发', 'WXT']
---

# **2025 浏览器扩展框架现状：Plasmo、WXT 与 CRXJS 对比分析**

## **第 1 节：执行摘要**

### **1.1 当前市场领导者**

2025 年的浏览器扩展开发环境因强制迁移至 Manifest V3（MV3）以及持续的跨浏览器 API 不一致而日益复杂。在这一严峻形势下，一个明确的市场领导者已经浮现。对现有框架的功能集、开发者体验及生态系统健康度的综合分析表明，**WXT** 已确立为现代浏览器扩展开发的权威领先框架。其领导地位建立在卓越的开发者体验、强大而灵活的功能集、框架无关的架构所带来的广泛兼容性，以及最关键的一点——长期且可靠的开源维护记录之上。

### **1.2 竞争者一览**

市场主要由三大玩家定义，各自拥有鲜明的理念与权衡：

* **WXT：** 本报告推荐绝大多数新浏览器扩展项目采用 WXT。它在强大功能、架构灵活性与长期项目稳定性之间取得了最有效的平衡。其活跃的社区及在高规模生产扩展中的成功应用进一步巩固了其作为最审慎、最高效选择的地位。
* **Plasmo：** 一个功能强大、高度固执己见的框架，为 React 团队提供了极佳的初始开发者体验。其“扩展版 Next.js”理念提供了流畅的声明式工作流。然而，其长期可行性因社区对其维护状态的广泛担忧以及对相对落后的 Parcel 打包器的依赖而严重受损，后者在现代工具链生态中已逐渐落伍。
* **CRXJS：** 一个轻量而强大的 Vite 插件，而非完整框架。它在构建流程中表现卓越，为内容脚本提供了顶级的热模块替换（HMR）。CRXJS 是那些需要最大控制权、希望避免完整框架抽象的高级团队的理想选择。然而，随着 WXT 等全面框架采用同样的底层 Vite 技术并提供更完整的开箱即用解决方案，其价值主张正在收窄。

### **1.3 关键战略要务**

本报告的核心发现是，浏览器扩展的技术格局已成熟到框架间微小功能差异的重要性已不如各自开源生态系统的健康与活力。框架能否及时为新浏览器版本提供更新、修补安全漏洞并与更广泛的 JavaScript 工具链演进保持同步，已成为关键。因此，框架社区的实证健康度及其维护者的活跃度已成为技术选型中最重要的因素，直接影响长期项目风险与总拥有成本。

## **第 2 节：现代浏览器扩展开发格局**

要充分理解现代扩展框架的价值主张，必须先了解它们所处的复杂技术环境。当前格局由三大挑战定义：向 Manifest V3 的架构迁移、持续的跨浏览器 API 碎片化，以及扩展核心组件固有的解耦特性。这些挑战共同抬高了开发的基准复杂度，使得采用稳健框架对任何规模可观的项目几乎成为必需。

### **2.1 不可避免的迁移：Manifest V3（MV3）**

由 Google 主导的 Chrome 浏览器从 Manifest V2 到 MV3 的迁移，是多年来扩展架构最重大的范式转变。核心变化是用短暂的服务工作线程（service worker）取代持久后台页面。在 MV2 下，后台脚本可无限期运行，在整个浏览器会话期间将状态保存在内存中。而在 MV3 下，服务工作线程是事件驱动的，浏览器可随时终止它以节省资源，且不保证其持久性。

这一架构变化从根本上改变了扩展的设计方式。它迫使开发者采用无状态、事件驱动的模型，所有关键信息必须在服务工作线程终止前持久化到存储中。这引入了管理应用状态、处理异步操作以及确保服务工作线程重新激活时事件监听器正确注册的巨大复杂性。MV3 的迁移提升了浏览器的安全性与性能，但将更大的架构负担转嫁给了开发者，使得现代框架提供的抽象比以往任何时候都更有价值。

### **2.2 跨浏览器难题**

尽管 WebExtensions API 已带来一定程度的标准化，但由于关键实现差异，为多浏览器开发仍是一项重大挑战。这些不一致主要体现在：

* **API 命名空间：** Firefox 与 Safari 主要使用基于 Promise 的异步操作 `browser.*` 命名空间。基于 Chromium 的浏览器（Chrome、Edge、Opera）历史上使用基于回调的 `chrome.*` 命名空间，尽管它们已逐步添加 Promise 支持。
* **功能可用性：** 整个 API 模块或 API 中的特定方法可能在一个浏览器中可用，而在另一个中不可用。例如，Firefox 通过 `contextualIdentities` API 支持容器标签，而 Chrome 则不支持。
* **行为差异：** 即使 API 受支持，其行为也可能不同。一个显著例子是内容脚本与宿主页面 JavaScript 环境的交互方式。Chrome 使用“隔离世界”概念防止冲突，而 Firefox 采用不同的安全模型“Xray vision”。

手动管理这些差异需要大量条件代码、polyfill 及浏览器特定构建配置。现代扩展框架的主要功能之一便是抽象掉这种复杂性，提供单一、统一的 API，让开发者“一次编写，到处部署”。

### **2.3 扩展生命周期的复杂性**

浏览器扩展不是一个单体应用，而是一组必须通信才能正常工作的独立、往往隔离的组件。这些组件通常包括：

* **后台服务工作线程：** 扩展的中央事件处理器与状态管理器。
* **弹出 UI：** 用户点击扩展工具栏图标时显示的短暂 HTML 页面。
* **内容脚本：** 直接注入网页以读取或修改其内容的 JavaScript 与 CSS 文件。
* **选项页：** 用于用户配置的持久 HTML 页面。

这些组件运行在不同上下文中，无法直接调用函数或共享内存。所有通信必须通过消息传递系统进行，通常使用 `runtime.sendMessage` 与 `runtime.onMessage` API。管理这种异步通信，尤其是涉及多个组件的复杂交互，往往导致大量样板代码，并可能成为常见 bug 来源。框架旨在通过提供更高级别的消息 API 或其他状态管理解决方案来简化这一过程。MV3 生命周期管理、跨浏览器 API 碎片化及消息传递架构固有复杂性的综合影响，使得从零构建非平凡扩展成为低效且易错之举。框架不再是开发奢侈品，而是构建可维护、可扩展、健壮浏览器扩展的战略必需品。

## **第 3 节：深度分析：Plasmo 框架**

Plasmo 框架定位为“由黑客为黑客打造的电池满载浏览器扩展 SDK”，旨在为扩展提供类似 Next.js 之于 Web 应用的开发体验。它建立在高度固执己见、声明式理念之上，旨在最小化配置并加速开发，尤其面向 React 生态系统团队。

### **3.1 架构深度剖析：“扩展版 Next.js”**

Plasmo 的核心架构原则是对 `manifest.json` 文件的抽象。开发者无需手动配置入口点与权限，框架会根据项目文件结构自动生成清单。放置在特定目录或按约定命名的文件（如 `popup.tsx`、`options.tsx`、`content.ts`、`background.ts`）会被自动识别并接入最终扩展包。这种声明式、基于文件的路由系统有意模仿 Next.js，为 Web 开发者提供熟悉模式。

一个关键且差异化的架构决策是 Plasmo 使用 **Parcel** 打包器。尽管 Parcel 以零配置著称，但这一选择与采用更现代、高性能 Vite 工具链的 WXT 与 CRXJS 形成对比。正如将讨论的，对 Parcel 的依赖已成为技术债务的重要来源及开发者社区的担忧点。

### **3.2 开发者体验（DX）：固执己见且流畅**

Plasmo 明确面向 React 与 TypeScript 开发者设计，为此技术栈提供开箱即用的一流支持。开发工作流通过简单脚手架命令 `pnpm create plasmo` 启动，可通过标志从初始阶段集成 TailwindCSS 或 Supabase。

开发服务器提供实时重载，代码变更时自动刷新扩展。然而，其开发者体验的一个关键限制是，更高级的热模块替换（HMR）能力（允许有状态更新而无需完全重载）几乎仅为 React 优化。使用框架对 Vue 或 Svelte 可选支持的团队不会体验到相同水平的开发速度，因为变更往往会触发完整扩展重载。

### **3.3 核心功能与抽象**

Plasmo 的“电池满载”特性在其丰富的内置功能与旨在简化常见扩展开发任务的高级抽象中显而易见。

* **API 封装：** 框架包含自己的核心扩展功能高级 API。存储 API 为持久化数据提供简化接口，消息 API 抽象底层 `chrome.runtime.sendMessage` 系统的复杂性，使后台、弹出窗口与内容脚本之间的通信更直接。
* **内容脚本 UI（CSUI）：** 这是 Plasmo 最引人注目的功能之一。它提供了一种简化方式，通过内容脚本将复杂 UI 组件（如 React 构建的组件）直接渲染到网页上。关键之处在于，Plasmo 可自动将这些 UI 封装在 Shadow DOM 中，将扩展的 CSS 与宿主页面样式隔离，防止冲突——这是手动解决时常见且困难的问题。
* **部署与发布：** Plasmo 生态系统超越核心框架，包含整个扩展生命周期的工具。开源的 Browser Platform Publisher（BPP）是一个 GitHub Action，可自动将扩展部署到 Chrome、Firefox 与 Edge 商店。此外，Plasmo 提供名为 Itero TestBed 的商业软件即服务（SaaS）产品，为扩展提供测试环境，并向 Beta 测试者推送更新，无需经过官方商店审核流程。

### **3.4 生态系统与可行性：警示故事**

尽管其功能集令人印象深刻，且在 GitHub 上拥有大量星标（12.3k），Plasmo 框架的长期可行性却是重大关切。越来越多的开发者社区证据表明，该项目未以生产关键工具所需水平进行积极维护。

WXT 官方对比文档明确指出 Plasmo“似乎处于维护模式，几乎没有维护者或功能开发”。这一断言得到 Reddit 等平台开发者轶事报告的支持。一位用户强烈建议不要采用该框架，称“任何考虑使用 Plasmo 的人请不要这样做。他们在 Parcel 大版本上落后，且从代码状态来看，迁移并不简单”。这种依赖滞后带来了实际后果，例如无法使用 TailwindCSS v4 等现代工具。

Itero TestBed 等付费商业层的存在进一步复杂化了局面，引发了对项目资源在开源框架与商业产品之间分配的问题。尽管高星标数表明过去的受欢迎程度，但社区的定性反馈指向一个难以跟上快速演进 Web 生态系统的项目。

这种情况呈现了一个经典的“好主意，高风险执行”困境。Plasmo 的概念模型，以其声明式架构与强大抽象，几乎适用于现代扩展开发。然而，框架的价值与其持续维护密不可分。为新项目采用 Plasmo 意味着承担重大风险，即框架不会及时更新以支持未来浏览器 API 变更、解决安全漏洞或保持与更广泛 JavaScript 工具链的兼容性。对于大多数专业与企业团队，这种风险水平可能超过其功能集带来的好处。

## **第 4 节：深度分析：WXT 框架**

WXT 定位为“下一代 Web 扩展框架”，深受 Nuxt.js 以开发者为中心理念的启发。其设计基于两个主要目标：提供一流的开发者体验（DX）与对所有主流浏览器的一流统一支持。它已迅速获得关注，现被广泛视为构建健壮、跨浏览器扩展的首选。

### **4.1 架构深度剖析：受 Nuxt 启发且框架无关**

WXT 最重要的架构优势是其 **前端框架无关性**。与 Plasmo 的 React 中心方法不同，WXT 设计为与任何拥有 Vite 插件的现代 UI 框架协同工作。它为最受欢迎的选择——React、Vue、Svelte 与 SolidJS——提供预配置的官方模块，但不排除其他框架的使用。这种灵活性使 WXT 成为极其通用且面向未来的选择，因为它不会将开发团队锁定在特定 UI 技术上。

WXT 的核心建立在 **Vite** 之上，现代前端构建工具。这一基础选择为 WXT 带来了显著的性能优势，包括利用原生 ES 模块进行热模块替换（HMR）的极快开发服务器，以及由 Rollup 驱动的高度优化生产构建。与现代 Vite 生态系统的对齐是其卓越性能与开发者体验的关键因素。

### **4.2 开发者体验（DX）：一流工具链**

WXT 经过精心设计，通过一套强大的 DX 功能最小化开发者摩擦并减少样板代码。

* **基于文件的入口点：** 与 Plasmo 类似，WXT 采用基于文件的系统，其中 `manifest.json` 从 `entrypoints/` 目录中的文件自动生成。然而，WXT 通过允许直接在入口点文件中使用内联配置选项增强了这一模式，为清单生成提供了更细粒度的控制。
* **自动导入：** 受 Nuxt 启发的突出功能，WXT 提供组件、钩子与实用函数的自动按需导入。这消除了数十个手动导入语句的需求，使代码更简洁，显著提升开发者生产力。
* **开发模式：** 框架的开发模式因其速度广受赞誉，为 UI 开发提供“闪电般快速的 HMR”，为内容/后台脚本提供快速重载。用户证词证实总体积极体验，尽管热重载的 websocket 连接偶尔可能不稳定。
* **CLI：** 项目脚手架由交互式命令行界面（CLI）处理，通过 `npx wxt@latest init` 调用。该工具引导开发者选择项目名称、UI 框架模板（包括 vanilla TypeScript）及其他初始设置选项，可在几秒内启动新项目。

### **4.3 核心功能与抽象**

WXT 提供了一套全面的功能，解决了跨浏览器扩展开发的主要痛点。

* **统一浏览器 API：** WXT 暴露一个全局 `browser` 对象，作为底层 WebExtensions API 的一致、基于 Promise 的封装。这一抽象层自动处理 Chrome 的 `chrome.*` 命名空间与 Firefox 的 `browser.*` 命名空间之间的差异，使开发者能够编写在所有目标浏览器中正确运行的单一、简洁代码库。
* **全面构建与发布：** 框架为整个部署管道提供了强大的内置工具。它包括为不同浏览器商店生成优化 ZIP 包的命令，包括创建单独的源代码 ZIP 文件，这是提交到 Mozilla 附加组件商店的要求。此外，WXT 提供自动化扩展上传与发布流程的实用程序。
* **模块系统：** 对于维护一系列相关扩展的组织，WXT 提供了强大的模块系统。此功能支持创建可重用模块，可在多个扩展项目之间共享构建时配置与运行时代码，促进代码重用并简化维护。

### **4.4 生态系统与可行性：活跃且繁荣**

WXT 的可行性得到其广泛采用与活跃社区的强力支持。框架官方网站展示了使用 WXT 构建的流行、生产就绪扩展的画廊，包括多个拥有庞大用户群的扩展，如“Eye Dropper”（100 万+用户）与“ChatGPT Writer”（60 万+用户）。这为其稳定性与可扩展性提供了有力的社会证明。

项目得到积极维护，GitHub 上有健康且响应迅速的存在（7.9k 星标），Discord 上有活跃社区提供用户支持。开发者情绪压倒性地积极，众多公开账户证实团队成功从 Plasmo 迁移到 WXT，并报告性能与开发者体验的“显著提升”。

框架的 UI 框架无关架构决策是一个重要的战略优势。它不仅迎合了更广泛的开发者受众，还使构建的项目面向未来。通过将核心扩展逻辑与 UI 渲染层解耦，WXT 确保团队可以为其需求采用最佳 UI 技术，而不受框架限制。这种灵活性使 WXT 成为长期项目更具弹性与战略性的选择，因为它可以轻松适应前端生态系统的未来趋势。

## **第 5 节：深度分析：CRXJS Vite 插件**

CRXJS 在扩展开发生态系统中占据独特地位。务必理解 CRXJS 并非与 Plasmo 或 WXT 同类的全面、一体化框架。相反，它是一个高度专注的 **Vite 插件**，旨在解决使用现代 Vite 工具链打包浏览器扩展的特定且复杂的挑战。其理念是极简与控制，提供必要的构建时能力，同时有意避免应用级抽象。

### **5.1 架构深度剖析：工具，而非框架**

`@crxjs/vite-plugin` 的核心目的是弥合 Vite 开发服务器与浏览器扩展环境独特需求之间的差距。它提供零配置设置，使开发者能够利用 Vite 及其广泛插件生态系统的全部功能进行扩展开发。

与 WXT 与 Plasmo 的基于文件的路由约定不同，CRXJS 遵循更传统的方法，其中 `manifest.json` 文件作为定义扩展入口点（后台脚本、内容脚本、弹出窗口等）的唯一真实来源。插件解析此清单并相应配置 Vite 的构建过程。此模型吸引那些偏好显式配置清单而非完整框架基于约定的“魔法”的开发者。

### **5.2 开发者体验（DX）：精简且无主见**

CRXJS 的主要开发者体验功能与关键技术成就是其实现的 **“适用于内容脚本的真实热模块替换”**。这是一个重要的差异化因素。尽管其他工具可以重载弹出窗口或选项页的 UI，CRXJS 能够将更新后的代码注入实时网页的内容脚本，而无需完全刷新页面，保留页面与扩展的状态。这为重度依赖内容脚本功能的扩展提供了显著的开发反馈循环加速。一些社区成员指出，其他框架中内容脚本的 HMR 水平不如 CRXJS，使其成为此特定用例的优越选择。

设置过程精简直接：开发者初始化标准 Vite 项目，安装 `@crxjs/vite-plugin` 包，并将其添加到 `vite.config.js` 文件中，指向项目的 `manifest.json`。这种极简方法赋予开发者最大控制权，因为他们可以自由构建应用并选择自己的库来处理存储与消息传递等任务，而不受框架约定约束。

### **5.3 核心功能**

CRXJS 专注于狭窄但关键的一组职责：

* **Vite 集成与 HMR：** 其主要功能是使用 Vite 正确打包所有扩展组件，并管理扩展页面（弹出窗口、选项页）与内容脚本的 HMR 连接。
* **Web 可访问资源：** 它自动化了在清单的 `web_accessible_resources` 字段中声明资源的过程。这是开发者手动错误的常见来源，插件能够根据代码中的静态资源导入自动管理这些条目，显著提升了开发体验。

务必注意 CRXJS **不提供** 的内容。没有内置封装器或抽象用于浏览器的存储、消息传递或国际化（i18n）API。使用 CRXJS 的开发者需直接与原生 `chrome.*` 或 `browser.*` API 交互，或选择并集成自己的第三方库来处理这些需求。

### **5.4 生态系统与可行性：担忧迹象**

项目的历史与维护状态一直是社区担忧的来源。Vite 插件在 2025 年 6 月官方 2.0 版本发布前，曾处于测试状态超过三年。在这段漫长的测试期间，曾有关于项目无人维护或可能被归档的讨论，这可能影响了其采用。

尽管新的活跃维护者团队最近接管了项目并推动了官方 2.0 版本发布，但这种不稳定的历史可能会让潜在采用者犹豫